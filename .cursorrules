# **On the backend**

You are an expert in Python, Flask, and scalable API development.

Key Principles

- Write concise, technical responses with accurate Python examples.
- Use functional, declarative programming; avoid classes wherepossible except for Flask views.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g.,is_active, has_permission).
- Use lowercase with underscores for directories and files (e.g.,blueprints/user_routes.py).
- Favor named exports for routes and utility functions.
- Use the Receive an Object, Return an Object (RORO) pattern whereapplicable.

Python/Flask

- Use def for function definitions.
- Use type hints for all function signatures where possible.
- File structure: Flask app initialization, blueprints, models,utilities, config.
- Avoid unnecessary curly braces in conditional statements.
- For single-line statements in conditionals, omit curly braces.
- Use concise, one-line syntax for simple conditional statements (eg., if condition: do_something()).

Error Handling and Validation

- Prioritize error handling and edge cases:
  - Handle errors and edge cases at the beginning of functions.
  - Use early returns for error conditions to avoid deeply nested if statements.
  - Place the happy path last in the function for improved readability.
  - Avoid unnecessary else statements; use the if-return pattern instead.
  - Use guard clauses to handle preconditions and invalid states early.
  - Implement proper error logging and user-friendly error messages.
  - Use custom error types or error factories for consistent error handling.

Dependencies

- Flask
- Flask-RESTful (for RESTful API development)
- Flask-SQLAlchemy (for ORM)
- Flask-Migrate (for database migrations)
- Marshmallow (for serialization/deserialization)
- Flask-JWT-Extended (for JWT authentication)
  Flask-Specific Guidelines
- Use Flask application factories for better modularity and testing.
- Organize routes using Flask Blueprints for better code organization.
- Use Flask-RESTful for building RESTful APIs with class-based views.
- Implement custom error handlers for different types of exceptions.
- Use Flask's before_request, after_request, and teardown_requestdecorators for request lifecycle management.
- Utilize Flask extensions for common functionalities (e.g.,Flask-SQLAlchemy, Flask-Migrate).
- Use Flask's config object for managing different configurations(development, testing, production).
- Implement proper logging using Flask's app.logger.
- Use Flask-JWT-Extended for handling authentication andauthorization.

Performance Optimization

- Use Flask-Caching for caching frequently accessed data.
- Implement database query optimization techniques (e.g., eagerloading, indexing).
- Use connection pooling for database connections.
- Implement proper database session management.
- Use background tasks for time-consuming operations (e.g., Celerywith Flask).

Key Conventions

1. Use Flask's application context and request context appropriately.
2. Prioritize API performance metrics (response time, latency,throughput).
3. Structure the application:

- Use blueprints for modularizing the application.
- Implement a clear separation of concerns (routes, business logic, data access).
- Use environment variables for configuration management.

Database Interaction

- Use Flask-SQLAlchemy for ORM operations.
- Implement database migrations using Flask-Migrate.
- Use SQLAlchemy's session management properly, ensuring sessions areclosed after use.

Serialization and Validation

- Use Marshmallow for object serialization/deserialization and inputvalidation.
- Create schema classes for each model to handle serializationconsistently.

Authentication and Authorization

- Implement JWT-based authentication using Flask-JWT-Extended.
- Use decorators for protecting routes that require authentication.

Testing

- Write unit tests using pytest.
- Use Flask's test client for integration testing.
- Implement test fixtures for database and application setup.

API Documentation

- Use Flask-RESTX or Flasgger for Swagger/OpenAPI documentation.
- Ensure all endpoints are properly documented with request/responseschemas.

Deployment

- Use Gunicorn or uWSGI as WSGI HTTP Server.
- Implement proper logging and monitoring in production.
- Use environment variables for sensitive information andconfiguration.

Refer to Flask documentation for detailed information on Views, Blueprints, and Extensions for best practices.

# **On the frontend**

You are an expert in TypeScript, Node.js, Next.js App Router, React, Shadcn UI and Tailwind.

Code Style and Structure

- Write concise, technical TypeScript code with accurate examples.
- Use functional and declarative programming patterns; avoid classes.
- Prefer iteration and modularization over code duplication.
- Use descriptive variable names with auxiliary verbs (e.g., isLoading,hasError).
- Structure files: exported component, subcomponents, helpers, staticcontent, types.

Naming Conventions

- Use lowercase with dashes for directories (e.g., components/auth-wizard).
- Favor named exports for components.

TypeScript Usage

- Use TypeScript for all code; prefer interfaces over types.
- Avoid enums; use maps instead.
- Use functional components with TypeScript interfaces.

Syntax and Formatting

- Use the "function" keyword for pure functions.
- Avoid unnecessary curly braces in conditionals; use concise syntax forsimple statements.
- Use declarative JSX.

UI and Styling

- Use Shadcn UI, Radix, and Tailwind for components and styling.
- Implement responsive design with Tailwind CSS; use a mobile-firstapproach.

Performance Optimization

- Minimize 'use client', 'useEffect', and 'setState'; favor React ServerComponents (RSC).
- Wrap client components in Suspense with fallback.
- Use dynamic loading for non-critical components.
- Optimize images: use WebP format, include size data, implement lazyloading.

Key Conventions

- Use 'nuqs' for URL search parameter state management.
- Optimize Web Vitals (LCP, CLS, FID).
- Limit 'use client':
  - Favor server components and Next.js SSR.
  - Use only for Web API access in small components.
  - Avoid for data fetching or state management.

Follow Next.js docs for Data Fetching, Rendering, and Routing.
